# This file contains the fastlane.tools configuration
# You can find the documentation at https://docs.fastlane.tools
#
# For a list of all available actions, check out
#
#     https://docs.fastlane.tools/actions
#

# Uncomment the line if you want fastlane to automatically update itself
# update_fastlane

#####

# Project specific variables

workspace = "DevStack.xcworkspace"
slack_channel = "#ci"

alpha = {
  output_name: "A-DevStack",
  app_identifier: "cz.matee.devstack.alpha",
  scheme: "DevStack_Alpha",
  plist_path: "./DevStack/App/Config/Info-Alpha.plist",
  gsp_path: "./DevStack/App/Config/GoogleService-Info-Alpha.plist",
  testflight_groups: ['App Store Connect Users', 'Public'],
  testflight_link: "NOT AVAILABLE"
}

beta = {
  output_name: "B-DevStack",
  app_identifier: "cz.matee.devstack.beta",
  scheme: "DevStack_Beta",
  plist_path: "./DevStack/App/Config/Info-Beta.plist",
  gsp_path: "./DevStack/App/Config/GoogleService-Info-Beta.plist",
  testflight_groups: ['App Store Connect Users', 'Public'],
  testflight_link: "NOT AVAILABLE"
}

production = {
  output_name: "DevStack",
  app_identifier: "cz.matee.devstack",
  scheme: "DevStack",
  plist_path: "./DevStack/App/Config/Info.plist",
  gsp_path: "./DevStack/App/Config/GoogleService-Info.plist",
  testflight_groups: ['App Store Connect Users', 'Public'],
  testflight_link: "NOT AVAILABLE"
}

#####

# Variables shared among all projects (do not change unless necessary)

matee = {
  apple_id: "mateefastlane@gmail.com",
  team_id_dev: "WNB34WBN42",
  team_id_connect: "120470944",
  match_branch: "master",
  certificate: "iPhone Distribution: Matee Devs s.r.o."
}

match_url = "git@github.com:MateeDevs/match.git"
slack_url = "https://hooks.slack.com/services/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"

#####

# Variables to specify developer for production release

client = {
  apple_id: matee[:apple_id],
  team_id_dev: matee[:team_id_dev],
  team_id_connect: matee[:team_id_connect],
  match_branch: matee[:match_branch],
  certificate: matee[:certificate]
}

#####

default_platform(:ios)

platform :ios do
  before_all do
    ENV["SLACK_URL"] = slack_url
  end

  # BUILD

  desc "Create a new Alpha build"
  lane :build_alpha do |options|
    build(alpha.merge(matee).merge(options))
  end

  desc "Create a new Beta build"
  lane :build_beta do |options|
    build(beta.merge(matee).merge(options))
  end

  desc "Create a new Production build"
  lane :build_production do |options|
    build(production.merge(client).merge(options))
  end

  desc "Create a new build"
  private_lane :build do |config|
    if config[:git_branch] !~ /build\/+\d\.+\d?\.*\d$/
      UI.user_error!("Invalid git branch: \"#{config[:git_branch]}\". Expected: \"build/x.x.x\".")
    end
    increment_version_number(version_number: config[:git_branch].split('/').last)
    increment_build_number(build_number: config[:build_number])
    match(
      username: config[:apple_id],
      team_id: config[:team_id_dev],
      app_identifier: config[:app_identifier],
      git_url: match_url,
      git_branch: config[:match_branch],
      type: "appstore"
    )
    gym(
      workspace: workspace,
      scheme: config[:scheme],
      clean: true,
      export_method: "app-store",
      codesigning_identity: config[:certificate],
      xcargs: "PROVISIONING_PROFILE_SPECIFIER='match AppStore #{config[:app_identifier]}'",
      archive_path: "#{config[:output_name]}.xcarchive",
      output_name: config[:output_name]
    )
    upload_symbols_to_crashlytics(
      dsym_path: "./#{config[:output_name]}.app.dSYM.zip", 
      gsp_path: config[:gsp_path]
    )
  end

  # RELEASE VIA TESTFLIGHT

  desc "Release the Alpha build via TestFlight"
  lane :release_alpha do
    release_testflight(alpha.merge(matee))
  end

  desc "Release the Beta build via TestFlight"
  lane :release_beta do
    release_testflight(beta.merge(matee))
  end

  desc "Release the Production build via TestFlight"
  lane :release_production_testflight do
    release_testflight(production.merge(client))
  end

  desc "Release the build via TestFlight"
  private_lane :release_testflight do |config|
    version = get_info_plist_value(path: config[:plist_path], key: "CFBundleShortVersionString")
    build = get_info_plist_value(path: config[:plist_path], key: "CFBundleVersion")
    pilot(
      ipa: "./#{config[:output_name]}.ipa",
      username: config[:apple_id],
      dev_portal_team_id: config[:team_id_dev],
      team_id: config[:team_id_connect],
      app_identifier: config[:app_identifier],
      groups: config[:testflight_groups],
      distribute_external: true,
      changelog: "#{config[:output_name]} #{version} build #{build}"
    )
    slack(
      message: "[iOS #{config[:output_name]}] #{version} build #{build} released via TestFlight\nLink: #{config[:testflight_link]}",
      channel: slack_channel,
      default_payloads: [],
      payload: {}
    )
  end

  # SUBMIT TO APPSTORE

  desc "Submit the Production build to the AppStore"
  lane :release_production_appstore do
    release_appstore(production.merge(client))
  end

  desc "Submit the build to the AppStore"
  private_lane :release_appstore do |config|
    version = get_info_plist_value(path: config[:plist_path], key: "CFBundleShortVersionString")
    build = get_info_plist_value(path: config[:plist_path], key: "CFBundleVersion")
    deliver(
      ipa: "./#{config[:output_name]}.ipa",
      username: config[:apple_id],
      dev_portal_team_id: config[:team_id_dev],
      team_id: config[:team_id_connect],
      app_identifier: config[:app_identifier],
      force: true,
      skip_screenshots: true,
      skip_metadata: true
    )
    slack(
      message: "[iOS #{config[:output_name]}] #{version} build #{build} submitted to the AppStore",
      channel: slack_channel,
      default_payloads: [],
      payload: {}
    )
  end

  # You can define as many lanes as you want

  after_all do |lane|
    # This block is called, only if the executed lane was successful
  end

  error do |lane, exception|
    # This block is called, only if there was an error in the executed lane
  end
end
